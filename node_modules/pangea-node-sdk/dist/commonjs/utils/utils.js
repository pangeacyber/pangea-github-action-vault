"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestEnvironment = void 0;
exports.eventOrderAndStringifySubfields = eventOrderAndStringifySubfields;
exports.canonicalize = canonicalize;
exports.canonicalizeEnvelope = canonicalizeEnvelope;
exports.canonicalizeEvent = canonicalizeEvent;
exports.strToB64 = strToB64;
exports.b64toStr = b64toStr;
exports.hashSHA256 = hashSHA256;
exports.hashSHA1 = hashSHA1;
exports.hashSHA512 = hashSHA512;
exports.hashNTLM = hashNTLM;
exports.getHashPrefix = getHashPrefix;
exports.getTestDomain = getTestDomain;
exports.getTestToken = getTestToken;
exports.getVaultSignatureTestToken = getVaultSignatureTestToken;
exports.getMultiConfigTestToken = getMultiConfigTestToken;
exports.getConfigID = getConfigID;
exports.getCustomSchemaTestToken = getCustomSchemaTestToken;
exports.getFileUploadParams = getFileUploadParams;
const node_buffer_1 = require("node:buffer");
const node_crypto_1 = __importDefault(require("node:crypto"));
const node_fs_1 = __importDefault(require("node:fs"));
const crc32c_1 = require("@aws-crypto/crc32c");
const crypto_js_1 = __importDefault(require("crypto-js"));
const errors_js_1 = require("../errors.js");
function orderKeysRecursive(obj) {
    const orderedEntries = Object.entries(obj).sort((a, b) => a[0].localeCompare(b[0]));
    orderedEntries.forEach((value) => {
        if (value[1] instanceof Object) {
            value[1] = orderKeysRecursive(value[1]);
        }
    });
    return Object.fromEntries(orderedEntries);
}
function isAscii(c) {
    return c.codePointAt(0) <= 127;
}
function replacer(_key, value) {
    if (value instanceof Date) {
        return value.toISOString();
    }
    if (typeof value === "string") {
        return [...value]
            .map((c) => isAscii(c)
            ? c // Do nothing.
            : c
                .split("") // Split into code points.
                .map((p) => `\\u${p.codePointAt(0).toString(16)}`)
                .join(""))
            .join("");
    }
    return value;
}
function eventOrderAndStringifySubfields(obj) {
    const orderedEntries = Object.entries(obj).sort((a, b) => a[0].localeCompare(b[0]));
    orderedEntries.forEach((value) => {
        if (value[1] instanceof Date) {
            value[1] = value[1].toISOString();
        }
        else if (value[1] instanceof Object) {
            value[1] = JSON.stringify(value[1], replacer); // This is to stringify JSON objects in the same way server do
        }
    });
    return Object.fromEntries(orderedEntries);
}
function canonicalize(obj) {
    return JSON.stringify(orderKeysRecursive(obj), replacer);
}
function canonicalizeEnvelope(obj) {
    const objCopy = JSON.parse(JSON.stringify(obj));
    if (objCopy.event !== undefined) {
        objCopy.event = eventOrderAndStringifySubfields(objCopy.event);
    }
    return canonicalize(objCopy);
}
function canonicalizeEvent(obj) {
    return canonicalize(eventOrderAndStringifySubfields(obj));
}
function strToB64(data) {
    return node_buffer_1.Buffer.from(data, "utf8").toString("base64");
}
function b64toStr(data) {
    return node_buffer_1.Buffer.from(data, "base64").toString("utf8");
}
function hashSHA256(data) {
    var sha256 = crypto_js_1.default.algo.SHA256.create();
    sha256.update(data);
    return sha256.finalize().toString();
}
function hashSHA1(data) {
    var sha1 = crypto_js_1.default.algo.SHA1.create();
    sha1.update(data);
    return sha1.finalize().toString();
}
function hashSHA512(data) {
    var sha512 = crypto_js_1.default.algo.SHA512.create();
    sha512.update(data);
    return sha512.finalize().toString();
}
function hashNTLM(password) {
    // Calculate the MD4 hash
    const md4Hash = node_crypto_1.default.createHash("md4");
    md4Hash.update(node_buffer_1.Buffer.from(password, "utf16le"));
    // Get the NTLM hash as a hexadecimal string
    return md4Hash.digest("hex").toUpperCase();
}
function getHashPrefix(hash, len = 5) {
    return hash.substring(0, len);
}
// TODO: convert to enum
exports.TestEnvironment = {
    DEVELOP: "DEV",
    LIVE: "LVE",
    STAGING: "STG",
};
function loadEnvVar(name) {
    const value = process.env[name];
    if (value === undefined) {
        throw new Error(`${name} environment variable need to be set`);
    }
    return value;
}
function getTestDomain(environment) {
    const name = "PANGEA_INTEGRATION_DOMAIN_" + environment;
    return loadEnvVar(name);
}
function getTestToken(environment) {
    const name = "PANGEA_INTEGRATION_TOKEN_" + environment;
    return loadEnvVar(name);
}
function getVaultSignatureTestToken(environment) {
    const name = "PANGEA_INTEGRATION_VAULT_TOKEN_" + environment;
    return loadEnvVar(name);
}
function getMultiConfigTestToken(environment) {
    const name = "PANGEA_INTEGRATION_MULTI_CONFIG_TOKEN_" + environment;
    return loadEnvVar(name);
}
function getConfigID(environment, service, configNumber) {
    const name = `PANGEA_${service.toUpperCase()}_CONFIG_ID_${configNumber}_` + environment;
    return loadEnvVar(name);
}
function getCustomSchemaTestToken(environment) {
    const name = "PANGEA_INTEGRATION_CUSTOM_SCHEMA_TOKEN_" + environment;
    return process.env[name] || "";
}
function getFileUploadParams(file) {
    const hash = node_crypto_1.default.createHash("sha256");
    let data;
    if (typeof file === "string") {
        data = node_fs_1.default.readFileSync(file);
    }
    else if (node_buffer_1.Buffer.isBuffer(file)) {
        data = file;
    }
    else {
        throw new errors_js_1.PangeaErrors.PangeaError("Invalid file type");
    }
    const size = data.length;
    hash.update(data);
    const sha256hex = hash.digest("hex");
    const crcValue = (0, crc32c_1.crc32c)(data);
    return {
        sha256: sha256hex,
        crc32c: crcValue.toString(16),
        size: size,
    };
}
