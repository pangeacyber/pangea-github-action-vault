"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Verifier = exports.Signer = void 0;
const node_crypto_1 = require("node:crypto");
const fs_1 = __importDefault(require("fs"));
const types_js_1 = require("../types.js");
const errors_js_1 = require("../errors.js");
const allowedKeyTypes = ["ed25519"];
/**
 * Signer class to sign event in AuditService
 */
class Signer {
    privateKey;
    constructor(privateKeyFilename) {
        this.privateKey = (0, node_crypto_1.createPrivateKey)(fs_1.default.readFileSync(privateKeyFilename));
    }
    /**
     * @summary Sign data with private key and ED25519 algorithm
     * @description Fetch paginated results of a previously executed search
     * @param {String} data - data to be signed
     * @returns {string} - signature encoded in base64
     * @example
     * const signature = signer.sign("This is my message to sign")
     */
    sign(data) {
        if (!this.privateKey.asymmetricKeyType ||
            !allowedKeyTypes.includes(this.privateKey.asymmetricKeyType)) {
            throw new errors_js_1.PangeaErrors.PangeaError(`Key type not supported: ${this.privateKey.asymmetricKeyType}`);
        }
        const bytes = Buffer.from(data);
        const signature = (0, node_crypto_1.sign)(null, bytes, this.privateKey);
        return signature.toString("base64");
    }
    /**
     * @summary Get public key of signer
     * @description create public key from signer's private key and return it
     * @returns {string} - public key encoded in base64
     * @example
     * const publicKey = signer.getPublicKey()
     */
    getPublicKey() {
        const pubKey = (0, node_crypto_1.createPublicKey)(this.privateKey);
        const pem = pubKey.export({ format: "pem", type: "spki" });
        return String(pem);
    }
    getAlgorithm() {
        switch (this.privateKey.asymmetricKeyType) {
            case "ed25519":
                return types_js_1.Vault.AsymmetricAlgorithm.Ed25519;
            default:
                return undefined;
        }
    }
}
exports.Signer = Signer;
/**
 * Verifier class to check event signature in AuditService
 */
class Verifier {
    /**
     * @summary Verify signature data
     * @description Check if data and signature correspond with public key
     * @param {String} data - data to be verified
     * @param {String} signB64 - base64 encoded signature from data
     * @param {String} publicKeyInput - base64 encoded or pem data public key
     * @returns {String} - True if signature correspond with public key, false otherwise
     * @example
     * const result = verifier.verify("")
     */
    verify(data, signB64, publicKeyInput) {
        let pubKey;
        const bytes = Buffer.from(data);
        const signBytes = Buffer.from(signB64, "base64");
        if (publicKeyInput.startsWith("-----")) {
            pubKey = (0, node_crypto_1.createPublicKey)(publicKeyInput);
        }
        else {
            const publicKeyB64urlSafe = Buffer.from(publicKeyInput, "base64").toString("base64url");
            const rawKey = {
                crv: "Ed25519",
                x: publicKeyB64urlSafe,
                kty: "OKP",
            };
            try {
                const pubKey = (0, node_crypto_1.createPublicKey)({
                    key: rawKey,
                    format: "jwk",
                });
                return (0, node_crypto_1.verify)(null, bytes, pubKey, signBytes);
            }
            catch {
                return false;
            }
        }
        return pubKey != undefined ? (0, node_crypto_1.verify)(null, bytes, pubKey, signBytes) : false;
    }
}
exports.Verifier = Verifier;
