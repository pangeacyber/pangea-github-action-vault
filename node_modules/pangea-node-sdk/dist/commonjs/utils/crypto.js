"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KEMkdf = exports.KEMSymmetricAlgorithm = exports.KEMHashAlgorithm = void 0;
exports.generateRsaKeyPair = generateRsaKeyPair;
exports.asymmetricDecrypt = asymmetricDecrypt;
exports.kemDecryptExportResult = kemDecryptExportResult;
const node_crypto_1 = __importDefault(require("node:crypto"));
const node_util_1 = require("node:util");
const types_js_1 = require("../types.js");
const generateKeyPair = (0, node_util_1.promisify)(node_crypto_1.default.generateKeyPair);
const IV_SIZE = 12; // Standard nonce size for GCM
/**
 * Generates a new RSA key pair of the given key size.
 * @param keySize Key size.
 * @returns RSA key pair.
 */
function generateRsaKeyPair(keySize = 4096) {
    return generateKeyPair("rsa", {
        modulusLength: keySize,
        publicKeyEncoding: {
            type: "spki",
            format: "pem",
        },
        privateKeyEncoding: {
            type: "pkcs8",
            format: "pem",
        },
    });
}
/**
 * Decrypt cipher text using the given asymmetric private key.
 * @param privateKey Asymmetric private key.
 * @param cipherText Cipher text.
 * @param oaepHash Hash function to use for OAEP padding and MGF1.
 * @param padding Padding value.
 * @returns Decrypted text.
 */
function asymmetricDecrypt(privateKey, cipherText, oaepHash = "sha512", padding = node_crypto_1.default.constants.RSA_PKCS1_OAEP_PADDING) {
    return node_crypto_1.default
        .privateDecrypt({
        key: privateKey,
        oaepHash,
        padding,
    }, cipherText)
        .toString("utf8");
}
async function kemDecrypt(input) {
    if (input.symmetricAlgorithm != KEMSymmetricAlgorithm.AES256_GCM) {
        throw Error(`Unsupported symmetric algorithm: ${input.symmetricAlgorithm}`);
    }
    if (input.asymmetricAlgorithm !=
        types_js_1.Vault.ExportEncryptionAlgorithm.RSA4096_NO_PADDING_KEM) {
        throw Error(`Unsupported asymmetric algorithm: ${input.asymmetricAlgorithm}`);
    }
    if (input.kdf != KEMkdf.PBKDF2) {
        throw Error(`Unsupported kdf: ${input.kdf}`);
    }
    if (input.hashAlgorithm != KEMHashAlgorithm.SHA512) {
        throw Error(`Unsupported hash algorithm: ${input.hashAlgorithm}`);
    }
    const salt = node_crypto_1.default.privateDecrypt({
        key: input.privateKey,
        padding: node_crypto_1.default.constants.RSA_NO_PADDING,
    }, input.encryptedSalt);
    const keyLength = getKeyLength(input.symmetricAlgorithm);
    const symmetricKey = node_crypto_1.default.pbkdf2Sync(Buffer.from(input.password), salt, input.iterationCount, keyLength, input.hashAlgorithm);
    const key = await node_crypto_1.default.subtle.importKey("raw", symmetricKey, {
        name: "AES-GCM",
    }, false, ["decrypt"]);
    const decrypted = await node_crypto_1.default.subtle.decrypt({ name: "AES-GCM", iv: input.iv }, key, input.cipher);
    const enc = new TextDecoder("ascii");
    return enc.decode(decrypted);
}
var KEMHashAlgorithm;
(function (KEMHashAlgorithm) {
    KEMHashAlgorithm["SHA512"] = "sha512";
})(KEMHashAlgorithm || (exports.KEMHashAlgorithm = KEMHashAlgorithm = {}));
var KEMSymmetricAlgorithm;
(function (KEMSymmetricAlgorithm) {
    KEMSymmetricAlgorithm["AES256_GCM"] = "AES-GCM-256";
})(KEMSymmetricAlgorithm || (exports.KEMSymmetricAlgorithm = KEMSymmetricAlgorithm = {}));
var KEMkdf;
(function (KEMkdf) {
    KEMkdf["PBKDF2"] = "pbkdf2";
})(KEMkdf || (exports.KEMkdf = KEMkdf = {}));
function getKeyLength(algorithm) {
    if (algorithm == KEMSymmetricAlgorithm.AES256_GCM) {
        return 32;
    }
    throw Error(`Unsupported algorithm: ${algorithm}`);
}
async function kemDecryptExportResult(result, password, privateKey) {
    let cipherEncoded = result.private_key;
    if (!cipherEncoded) {
        cipherEncoded = result.key;
    }
    if (!cipherEncoded) {
        throw TypeError("`private_key` or `key` should be set.");
    }
    const cipherWithIV = Buffer.from(cipherEncoded, "base64");
    const encryptedSalt = Buffer.from(result.encrypted_salt, "base64");
    const iv = cipherWithIV.subarray(0, IV_SIZE);
    const cipher = cipherWithIV.subarray(IV_SIZE);
    return await kemDecrypt({
        privateKey,
        cipher,
        iv: iv,
        password,
        encryptedSalt,
        symmetricAlgorithm: result.symmetric_algorithm,
        asymmetricAlgorithm: result.asymmetric_algorithm,
        kdf: result.kdf,
        iterationCount: result.iteration_count,
        hashAlgorithm: result.hash_algorithm,
    });
}
