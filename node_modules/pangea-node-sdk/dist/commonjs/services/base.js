"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_js_1 = __importDefault(require("../config.js"));
const request_js_1 = __importDefault(require("../request.js"));
class BaseService {
    serviceName;
    token;
    config;
    request_ = undefined;
    configID;
    /*
    Required:
      - serviceName: name of the service
      - token: a token to use with the service
  
    Optional:
      - config: a PangeaConfig object, uses defaults if non passed
    */
    constructor(serviceName, token, config, configID) {
        if (!serviceName)
            throw new Error("A serviceName is required");
        if (!token)
            throw new Error("A token is required");
        this.serviceName = serviceName;
        if (typeof token === "string") {
            this.token = token;
        }
        else {
            if (token.type !== "pangea_token")
                throw new Error(`Token passed as vault secret is not of type 'pangea_token', but of type '${token.type}'`);
            if (token.item_state !== "enabled")
                throw new Error("Token passed as vault secret is not currently enabled");
            const currentVersion = token.current_version;
            if (!currentVersion)
                throw new Error("Token passed as vault secret does not have a current version");
            if (currentVersion.state !== "active")
                throw new Error("Token passed as vault secret is not currently active");
            if (!currentVersion.secret)
                throw new Error("Vault secret field is not populated, cannot pass as token");
            this.token = currentVersion.secret;
        }
        this.configID = configID;
        this.config = new config_js_1.default({ ...config }) || new config_js_1.default();
    }
    async get(endpoint) {
        return await this.request.get(endpoint);
    }
    /**
     * `POST` request.
     *
     * @internal
     * @template R Result type.
     * @param endpoint Endpoint path.
     * @param data Request body.
     * @param options Additional options.
     * @returns A `Promise` of the response.
     */
    async post(endpoint, data, options = {}) {
        return await this.request.post(endpoint, data, options);
    }
    async downloadFile(url) {
        return await this.request.downloadFile(url);
    }
    async pollResult(request_id) {
        return await this.request.pollResult(request_id, true);
    }
    get request() {
        if (this.request_) {
            return this.request_;
        }
        this.request_ = new request_js_1.default(this.serviceName, this.token, this.config, this.configID);
        return this.request_;
    }
}
exports.default = BaseService;
