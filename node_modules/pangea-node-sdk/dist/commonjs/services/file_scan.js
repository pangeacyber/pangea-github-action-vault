"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileScanUploader = exports.FileScanService = void 0;
const base_js_1 = __importDefault(require("./base.js"));
const config_js_1 = __importDefault(require("../config.js"));
const types_js_1 = require("../types.js");
const utils_js_1 = require("../utils/utils.js");
const errors_js_1 = require("../errors.js");
const request_js_1 = __importDefault(require("../request.js"));
class FileScanService extends base_js_1.default {
    /**
     * Creates a new `FileScanService` with the given Pangea API token and
     * configuration.
     *
     * @param token Pangea API token.
     * @param config Configuration.
     *
     * @example
     * ```js
     * const config = new PangeaConfig({ domain: "pangea_domain" });
     * const client = new FileScanService("pangea_token", config);
     * ```
     *
     * @summary File Scan
     */
    constructor(token, config) {
        super("file-scan", token, config);
    }
    /**
     * @summary Scan
     * @description Scan a file for malicious content.
     * @operationId file_scan_post_v1_scan
     * @param {FileScan.ScanRequest} request
     * @param {string} filepath
     * @param {FileScan.Options} options
     * @returns {Promise} - A promise representing an async call to the check endpoint
     * @example
     * ```js
     * const request = { verbose: true, raw: true, provider: "crowdstrike" };
     * const response = await client.fileScan(request, "./path/to/file.pdf");
     * ```
     */
    fileScan(request, file, // This param is optional. It should be null when using the source_url method
    options = {
        pollResultSync: true,
    }) {
        let fsData = {};
        if (request.transfer_method === types_js_1.TransferMethod.PUT_URL) {
            throw new errors_js_1.PangeaErrors.PangeaError(`${request.transfer_method} not supported in this function. Use getUploadURL() instead.`);
        }
        let postFile = undefined;
        let files = undefined;
        if (typeof file === "string") {
            postFile = {
                name: "file",
                file: file,
            };
        }
        else {
            postFile = file;
        }
        if (postFile) {
            files = {
                file: postFile,
            };
        }
        const postOptions = {
            pollResultSync: options.pollResultSync,
            files: files,
        };
        if ((!request.transfer_method ||
            request.transfer_method === types_js_1.TransferMethod.POST_URL) &&
            postFile) {
            fsData = (0, utils_js_1.getFileUploadParams)(postFile.file);
        }
        const fullRequest = {
            ...fsData,
            ...request,
        };
        return this.post("v1/scan", fullRequest, postOptions);
    }
    // TODO: Docs
    async requestUploadURL(request, options = {}) {
        if (request.transfer_method === types_js_1.TransferMethod.POST_URL &&
            !options.params) {
            throw new errors_js_1.PangeaErrors.PangeaError(`If transfer_method is ${types_js_1.TransferMethod.POST_URL} need to set options.params`);
        }
        let fsParams = {};
        if (request.transfer_method === types_js_1.TransferMethod.POST_URL && options.params) {
            fsParams = options.params;
        }
        const fullRequest = {
            ...fsParams,
            ...request,
        };
        return await this.request.requestPresignedURL("v1/scan", fullRequest);
    }
}
exports.FileScanService = FileScanService;
class FileScanUploader {
    serviceName = "FileScanFileUploader";
    request_ = undefined;
    constructor() { }
    get request() {
        if (this.request_) {
            return this.request_;
        }
        this.request_ = new request_js_1.default(this.serviceName, "unusedtoken", new config_js_1.default());
        return this.request_;
    }
    // TODO: Docs
    async uploadFile(url, fileData, options) {
        if (!options.transfer_method ||
            options.transfer_method === types_js_1.TransferMethod.PUT_URL) {
            await this.request.putPresignedURL(url, fileData);
        }
        else if (options.transfer_method === types_js_1.TransferMethod.POST_URL) {
            await this.request.postPresignedURL(url, fileData);
        }
    }
}
exports.FileScanUploader = FileScanUploader;
