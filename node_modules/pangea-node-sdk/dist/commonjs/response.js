"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PangeaResponse = exports.AttachedFile = exports.ResponseObject = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const multipart_js_1 = require("./utils/multipart.js");
const SupportedJSONFields = ["message", "new", "old"];
const decoder = new TextDecoder("utf-8");
/** Pangea response object. */
class ResponseObject {
    request_id = "InvalidPayloadReceived";
    request_time = "InvalidPayloadReceived";
    response_time = "InvalidPayloadReceived";
    status = "NoStatus";
    result = {};
    accepted_result;
    summary = "InvalidPayloadReceived";
    constructor(body) {
        Object.assign(this, body);
    }
}
exports.ResponseObject = ResponseObject;
class AttachedFile {
    filename;
    file;
    contentType;
    constructor(filename, file, contentType) {
        this.filename = filename;
        this.file = file;
        this.contentType = contentType;
    }
    save(destFolder, filename) {
        if (!destFolder) {
            destFolder = ".";
        }
        if (!filename) {
            filename = this.filename ? this.filename : "defaultSaveFilename";
        }
        if (!node_fs_1.default.existsSync(destFolder)) {
            // If it doesn't exist, create it
            node_fs_1.default.mkdirSync(destFolder, { recursive: true });
        }
        const filepath = node_path_1.default.resolve(destFolder, filename);
        node_fs_1.default.writeFileSync(filepath, Buffer.from(this.file));
    }
}
exports.AttachedFile = AttachedFile;
class PangeaResponse extends ResponseObject {
    gotResponse;
    success;
    attachedFiles = [];
    constructor(response, body) {
        let jsonResp = {};
        let attachedFilesTemp = [];
        const contentType = response.headers.get("content-type");
        if (contentType && contentType.includes("multipart")) {
            const boundary = (0, multipart_js_1.getBoundary)(contentType);
            const parts = (0, multipart_js_1.parse)(Buffer.from(body), boundary);
            parts.forEach((part, index) => {
                if (index == 0) {
                    jsonResp = JSON.parse(part.data.toString("utf-8"));
                }
                else {
                    attachedFilesTemp.push(new AttachedFile(part.filename, part.data, part.type));
                }
            });
        }
        else {
            jsonResp = JSON.parse(decoder.decode(body), parseJSONfields);
        }
        super(jsonResp);
        this.attachedFiles = attachedFilesTemp;
        this.gotResponse = response;
        this.success = this.status === "Success";
        this.result = this.result == null ? {} : this.result;
        if (this.gotResponse.status === 202) {
            this.accepted_result = this.result;
            this.result = {};
        }
    }
    // Return raw Pangea API response body
    body() {
        return this.gotResponse?.body;
    }
    // Return SDK PangeaResponse object as JSON (excluded raw API response body)
    toJSON() {
        return JSON.stringify({ ...this, gotResponse: undefined }, null, "  ");
    }
}
exports.PangeaResponse = PangeaResponse;
function parseJSONfields(key, value) {
    if (SupportedJSONFields.includes(key) && typeof value === "string") {
        try {
            const obj = JSON.parse(value);
            return obj;
        }
        catch (e) {
            return value;
        }
    }
    else {
        return value;
    }
}
exports.default = PangeaResponse;
