import got, { Options, HTTPError } from "got";
import FormData from "form-data";
import fs from "fs";
import { TransferMethod } from "./types.js";
import PangeaConfig, { version } from "./config.js";
import { ConfigEnv } from "./types.js";
import { PangeaErrors } from "./errors.js";
import { AttachedFile, PangeaResponse } from "./response.js";
import { getHeaderField } from "./utils/multipart.js";
const delay = async (ms) => new Promise((resolve) => {
    setTimeout(resolve, ms);
});
class PangeaRequest {
    serviceName;
    token;
    config;
    extraHeaders;
    configID;
    userAgent = "";
    constructor(serviceName, token, config, configID) {
        if (!serviceName)
            throw new Error("A serviceName is required");
        if (!token)
            throw new Error("A token is required");
        this.serviceName = serviceName;
        this.token = token;
        this.config = new PangeaConfig({ ...config });
        this.setCustomUserAgent(config.customUserAgent);
        this.extraHeaders = {};
        this.configID = configID;
    }
    checkConfigID(data) {
        if (this.configID && !data.config_id) {
            data.config_id = this.configID;
        }
    }
    /**
     * `POST` request.
     *
     * @template R Result type.
     * @param endpoint Endpoint path.
     * @param data Request body.
     * @param options Additional options.
     * @returns A `Promise` of the response.
     */
    async post(endpoint, data, options = {}) {
        const url = this.getUrl(endpoint);
        this.checkConfigID(data);
        let response;
        let entry = options.files ? Object.entries(options.files)[0] : undefined;
        if (options.files && entry) {
            if (data.transfer_method === TransferMethod.POST_URL) {
                response = await this.fullPostPresignedURL(endpoint, data, entry[1]);
            }
            else {
                response = await this.postMultipart(endpoint, data, options.files);
            }
        }
        else {
            let responseType = data.transfer_method == TransferMethod.MULTIPART ? "buffer" : "json";
            const request = new Options({
                headers: this.getHeaders(),
                json: data,
                retry: { limit: this.config.requestRetries },
                responseType: responseType,
            });
            response = await this.httpPost(url, request);
        }
        return this.handleHttpResponse(response, options);
    }
    getFilenameFromContentDisposition(contentDispositionHeader) {
        let contentDisposition = "";
        if (Array.isArray(contentDispositionHeader)) {
            contentDisposition = contentDispositionHeader[0] ?? contentDisposition;
        }
        return getHeaderField(contentDisposition, "filename", undefined);
    }
    getFilenameFromURL(url) {
        return new URL(url).pathname.split("/").pop();
    }
    async downloadFile(url) {
        const options = new Options({
            retry: { limit: this.config.requestRetries },
            responseType: "buffer",
        });
        const response = (await got.get(url, options));
        let filename = this.getFilenameFromContentDisposition(response.headers["Content-Disposition"]);
        if (filename === undefined) {
            filename = this.getFilenameFromURL(url);
            if (filename === undefined) {
                filename = "default_filename";
            }
        }
        const contentTypeHeader = response.headers["Content-Type"] ?? "";
        let contentType = "application/octet-stream";
        if (Array.isArray(contentTypeHeader)) {
            contentType = contentTypeHeader[0] ?? contentType;
        }
        return new AttachedFile(filename, response.rawBody, contentType);
    }
    async postMultipart(endpoint, data, files) {
        const url = this.getUrl(endpoint);
        const form = new FormData();
        this.checkConfigID(data);
        form.append("request", JSON.stringify(data), {
            contentType: "application/json",
        });
        for (let [name, fileData] of Object.entries(files)) {
            form.append(name, this.getFileToForm(fileData.file), {
                contentType: "application/octet-stream",
            });
        }
        const request = new Options({
            headers: this.getHeaders(),
            body: form,
            retry: { limit: this.config.requestRetries },
            responseType: "json",
        });
        return await this.httpPost(url, request);
    }
    getFileToForm(file) {
        if (typeof file === "string") {
            return fs.createReadStream(file);
        }
        return file;
    }
    getFileToBuffer(file) {
        if (typeof file === "string") {
            return fs.readFileSync(file);
        }
        return file;
    }
    async fullPostPresignedURL(endpoint, data, fileData) {
        const response = await this.requestPresignedURL(endpoint, data);
        if (!response.gotResponse || !response.accepted_result?.post_url) {
            throw new PangeaErrors.PangeaError("Failed to request post presigned URL");
        }
        const presigned_url = response.accepted_result.post_url;
        const file_details = response.accepted_result?.post_form_data;
        this.postPresignedURL(presigned_url, {
            file: fileData.file,
            file_details: file_details,
            name: fileData.name,
        });
        return response.gotResponse;
    }
    async postPresignedURL(url, fileData) {
        if (!fileData.file_details) {
            throw new PangeaErrors.PangeaError("file_details should be defined to do a post");
        }
        const form = new FormData();
        if (fileData.file_details) {
            for (const [key, value] of Object.entries(fileData.file_details)) {
                form.append(key, value);
            }
        }
        form.append("file", this.getFileToForm(fileData.file), {
            contentType: "application/octet-stream",
        });
        const request = new Options({
            body: form,
            retry: { limit: this.config.requestRetries },
            responseType: "json",
        });
        try {
            await this.httpPost(url, request);
        }
        catch (error) {
            if (error instanceof HTTPError) {
                throw new PangeaErrors.PresignedUploadError(`presigned POST failure: ${error.code}`, JSON.stringify(error.response.body));
            }
        }
        return;
    }
    async putPresignedURL(url, fileData) {
        if (fileData.file_details) {
            throw new PangeaErrors.PangeaError("file_details should be undefined to do a put");
        }
        const request = new Options({
            body: this.getFileToBuffer(fileData.file),
            retry: { limit: this.config.requestRetries },
            responseType: "json",
        });
        try {
            await got.put(url, request);
        }
        catch (error) {
            if (error instanceof HTTPError) {
                throw new PangeaErrors.PresignedUploadError(`presigned PUT failure: ${error.code}`, JSON.stringify(error.response.body));
            }
        }
        return;
    }
    async requestPresignedURL(endpoint, data) {
        let acceptedError;
        if (!data.transfer_method) {
            data.transfer_method = TransferMethod.PUT_URL;
        }
        try {
            await this.post(endpoint, data, {
                pollResultSync: false,
            });
            throw new PangeaErrors.PangeaError("This call should return 202");
        }
        catch (error) {
            if (!(error instanceof PangeaErrors.AcceptedRequestException)) {
                throw error;
            }
            else {
                acceptedError = error;
            }
        }
        return await this.pollPresignedURL(acceptedError.response);
    }
    async pollPresignedURL(response) {
        if (response.accepted_result &&
            (response.accepted_result.post_url || response.accepted_result.put_url)) {
            return response;
        }
        let retryCount = 0;
        const start = Date.now();
        let loopResponse = response;
        const body = loopResponse.gotResponse?.body;
        const requestId = body?.request_id;
        let loopError;
        while (!loopResponse.accepted_result?.post_url &&
            loopResponse.accepted_result?.put_url &&
            !this.reachTimeout(start)) {
            retryCount += 1;
            const waitTime = this.getDelay(retryCount, start);
            await delay(waitTime);
            try {
                loopResponse = await this.pollResult(requestId, false);
                throw new PangeaErrors.PangeaError("This call should return 202");
            }
            catch (error) {
                if (!(error instanceof PangeaErrors.AcceptedRequestException)) {
                    throw error;
                }
                else {
                    loopError = error;
                    loopResponse = error.pangeaResponse;
                }
            }
        }
        if (loopResponse.accepted_result?.post_url ||
            loopResponse.accepted_result?.put_url) {
            return loopResponse;
        }
        else {
            throw loopError;
        }
    }
    async httpPost(url, request) {
        try {
            return (await got.post(url, request));
        }
        catch (error) {
            if (error instanceof HTTPError) {
                // This MUST throw an error
                this.checkResponse(new PangeaResponse(error.response));
            }
            throw error;
        }
    }
    async handleHttpResponse(response, options = {}) {
        try {
            let pangeaResponse = new PangeaResponse(response);
            if (response.statusCode === 202) {
                if (options.pollResultSync !== false) {
                    pangeaResponse = await this.handleAsync(pangeaResponse);
                }
                return this.checkResponse(pangeaResponse);
            }
            return this.checkResponse(pangeaResponse);
        }
        catch (error) {
            if (error instanceof HTTPError) {
                // This MUST throw an error
                return this.checkResponse(new PangeaResponse(error.response));
            }
            // TODO: add handling of lower level errors?
            throw error;
        }
    }
    async get(endpoint, checkResponse = true) {
        const url = this.getUrl(endpoint);
        const options = new Options({
            headers: this.getHeaders(),
            retry: { limit: this.config.requestRetries },
            responseType: "json",
        });
        try {
            const response = (await got.get(url, options));
            const pangeaResponse = new PangeaResponse(response);
            return checkResponse
                ? this.checkResponse(pangeaResponse)
                : pangeaResponse;
        }
        catch (error) {
            if (error instanceof HTTPError) {
                // This MUST throw and error
                const pangeaResponse = new PangeaResponse(error.response);
                return checkResponse
                    ? this.checkResponse(pangeaResponse)
                    : pangeaResponse;
            }
            // TODO: add handling of lower level errors?
            throw error;
        }
    }
    getDelay(retryCount, start) {
        let delay = retryCount * retryCount * 1000;
        const now = Date.now();
        if (now + delay > start + this.config.pollResultTimeoutMs) {
            delay = start + this.config.pollResultTimeoutMs - now;
        }
        return delay;
    }
    reachTimeout(start) {
        const now = Date.now();
        return start + this.config.pollResultTimeoutMs <= now;
    }
    async pollResult(requestId, checkResponse = true) {
        const path = `request/${requestId}`;
        // eslint-disable-next-line no-await-in-loop
        return await this.get(path, checkResponse);
    }
    async handleAsync(pangeaResponse) {
        if (!this.config.queuedRetryEnabled) {
            return pangeaResponse;
        }
        let retryCount = 0;
        const start = Date.now();
        const body = pangeaResponse.gotResponse?.body;
        const requestId = body?.request_id;
        while (pangeaResponse.gotResponse?.statusCode === 202 &&
            !this.reachTimeout(start)) {
            retryCount += 1;
            const waitTime = this.getDelay(retryCount, start);
            // eslint-disable-next-line no-await-in-loop
            await delay(waitTime);
            pangeaResponse = await this.pollResult(requestId, false);
        }
        return pangeaResponse;
    }
    setExtraHeaders(headers) {
        this.extraHeaders = { ...headers };
    }
    setCustomUserAgent(customUserAgent) {
        this.config.customUserAgent = customUserAgent;
        this.userAgent = `pangea-node/${version}`;
        if (this.config.customUserAgent) {
            this.userAgent += ` ${this.config.customUserAgent}`;
        }
    }
    getUrl(path) {
        let url;
        if (this.config.domain.startsWith("http://") ||
            this.config.domain.startsWith("https://")) {
            url = `${this.config.domain}/${path}`;
        }
        else {
            const schema = this.config?.insecure === true ? "http://" : "https://";
            if (this.config?.environment == ConfigEnv.LOCAL) {
                url = `${schema}${this.config.domain}/${path}`;
            }
            else {
                url = `${schema}${this.serviceName}.${this.config.domain}/${path}`;
            }
        }
        return url;
    }
    getHeaders() {
        const headers = {};
        const pangeaHeaders = {
            "User-Agent": this.userAgent,
            Authorization: `Bearer ${this.token}`,
        };
        if (Object.keys(this.extraHeaders).length > 0) {
            Object.assign(headers, this.extraHeaders);
        }
        // We want to overwrite extraHeaders if user set some of pangea headers values.
        Object.assign(headers, pangeaHeaders);
        return headers;
    }
    checkResponse(response) {
        if (response.success) {
            return response;
        }
        if (response.gotResponse?.statusCode === 503) {
            throw new PangeaErrors.ServiceTemporarilyUnavailable(JSON.stringify(response.body));
        }
        switch (response.status) {
            case "ValidationError":
                throw new PangeaErrors.ValidationError(response.summary, response);
            case "TooManyRequests":
                throw new PangeaErrors.RateLimiteError(response.summary, response);
            case "NoCredit":
                throw new PangeaErrors.NoCreditError(response.summary, response);
            case "Unauthorized":
                throw new PangeaErrors.UnauthorizedError(this.serviceName, response);
            case "ServiceNotEnabled":
                throw new PangeaErrors.ServiceNotAvailableError(this.serviceName, response);
            case "ProviderError":
                throw new PangeaErrors.ProviderError(response.summary, response);
            case "MissingConfigIDScope":
            case "MissingConfigID":
                throw new PangeaErrors.MissingConfigID(this.serviceName, response);
            case "ServiceNotAvailable":
                throw new PangeaErrors.ServiceNotAvailableError(this.serviceName, response);
            case "InvalidPayloadReceived":
                throw new PangeaErrors.InvalidPayloadReceived(response.summary, response);
            case "ForbiddenVaultOperation":
                throw new PangeaErrors.ForbiddenVaultOperation(response.summary, response);
            case "NotFound":
                throw new PangeaErrors.NotFound(response.gotResponse?.requestUrl !== undefined
                    ? response.gotResponse.requestUrl.toString()
                    : "", response);
            case "InternalError":
                throw new PangeaErrors.InternalServerError(response);
            case "Accepted":
                throw new PangeaErrors.AcceptedRequestException(response);
            default:
                throw new PangeaErrors.APIError(response.status, response);
        }
    }
}
export default PangeaRequest;
